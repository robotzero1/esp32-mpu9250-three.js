<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lightning strike</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - lightning strike</div>

		<script type="module">

			import * as THREE from './build/three.module.js';

			import Stats from './examples/jsm/libs/stats.module.js';
			import { GUI } from './examples/jsm/libs/dat.gui.module.js';

			import { OrbitControls } from './examples/jsm/controls/OrbitControls.js';
			import { LightningStrike } from './examples/jsm/geometries/LightningStrike.js';
			import { EffectComposer } from './examples/jsm/postprocessing/EffectComposer.js';
			import { RenderPass } from './examples/jsm/postprocessing/RenderPass.js';
			import { OutlinePass } from './examples/jsm/postprocessing/OutlinePass.js';
			
import { GLTFLoader } from './examples/jsm/loaders/GLTFLoader.js';			

			var container, stats;

			var scene, renderer, composer, gui;

			var currentSceneIndex = 0;

			var currentTime = 0;

			var sceneCreators = [
				createConesScene,
			];

			var clock = new THREE.Clock();

			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2();
var loader = new GLTFLoader();			


			init();
			animate();
			


			function init() {

				container = document.getElementById( 'container' );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.outputEncoding = THREE.sRGBEncoding;

				container.appendChild( renderer.domElement );

				composer = new EffectComposer( renderer );

				stats = new Stats();
				container.appendChild( stats.dom );
				
				window.addEventListener( 'resize', onWindowResize, false );

				createScene();	
				
			var light2 = new THREE.AmbientLight( 0x404040  );
            light2.position.set( 1, 1, 1 );
            scene.add( light2 );
            
		var light = new THREE.PointLight( 0xffffcc, 20, 200 );
    light.position.set( 4, 30, -20 );
    scene.add( light );	
    
    			let axesHelper = new THREE.AxesHelper( 5 );
scene.add( axesHelper );
				
    loader.load(
        // resource URL
        'scene14_mixer_builder_creators3d.glb',
           // called when the resource is loaded
        function ( gltf ) {
        var object = gltf.scene;
            object.name="robot";
            object.position.set(0, 0, 0);
            scene.add( gltf.scene );

            },
            // called while loading is progressing
            function ( xhr ) {
        	    console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
                console.log( 'An error happened' );
            }
    );					



			}
			
		

			function createScene() {

				scene = sceneCreators[ currentSceneIndex ]();

				createGUI();

			}

			function onWindowResize() {

				scene.camera.aspect = window.innerWidth / window.innerHeight;
				scene.camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				composer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function createGUIold() {

				scene.timeRate = 1;

			}
			
			function createGUI() {

				if ( gui ) {

					gui.destroy();

				}

				gui = new GUI( { width: 350 } );

				var sceneFolder = gui.addFolder( "Scene" );

				scene.sceneIndex = currentSceneIndex;

				sceneFolder.add( scene, 'sceneIndex', { "Electric Cones": 0 } ).name( 'Scene' ).onChange( function ( value ) {

					currentSceneIndex = value;

					createScene();

				} );

				scene.timeRate = 1;
				sceneFolder.add( scene, 'timeRate', scene.canGoBackwardsInTime ? - 1 : 0, 1 ).name( 'Time rate' );

				sceneFolder.open();

				var graphicsFolder = gui.addFolder( "Graphics" );

				graphicsFolder.add( scene, "outlineEnabled" ).name( "Glow enabled" );

				scene.lightningColorRGB = [
					scene.lightningColor.r * 255,
					scene.lightningColor.g * 255,
					scene.lightningColor.b * 255
				];
				graphicsFolder.addColor( scene, 'lightningColorRGB' ).name( 'Color' ).onChange( function ( value ) {

					scene.lightningMaterial.color.setRGB( value[ 0 ], value[ 1 ], value[ 2 ] ).multiplyScalar( 1 / 255 );

				} );
				scene.userData.outlineColorRGB = [
					scene.outlineColor.r * 255,
					scene.outlineColor.g * 255,
					scene.outlineColor.b * 255
				];
				graphicsFolder.addColor( scene.userData, 'outlineColorRGB' ).name( 'Glow color' ).onChange( function ( value ) {

					scene.outlineColor.setRGB( value[ 0 ], value[ 1 ], value[ 2 ] ).multiplyScalar( 1 / 255 );

				} );

				graphicsFolder.open();

				var rayFolder = gui.addFolder( "Ray parameters" );

				rayFolder.add( scene.rayParams, 'straightness', 0, 1 ).name( 'Straightness' );
				rayFolder.add( scene.rayParams, 'roughness', 0, 1 ).name( 'Roughness' );
				rayFolder.add( scene.rayParams, 'radius0', 0.1, 10 ).name( 'Initial radius' );
				rayFolder.add( scene.rayParams, 'radius1', 0.1, 10 ).name( 'Final radius' );
				rayFolder.add( scene.rayParams, 'radius0Factor', 0, 1 ).name( 'Subray initial radius' );
				rayFolder.add( scene.rayParams, 'radius1Factor', 0, 1 ).name( 'Subray final radius' );
				rayFolder.add( scene.rayParams, 'timeScale', 0, 5 ).name( 'Ray time scale' );
				rayFolder.add( scene.rayParams, 'subrayPeriod', 0.1, 10 ).name( 'Subray period (s)' );
				rayFolder.add( scene.rayParams, 'subrayDutyCycle', 0, 1 ).name( 'Subray duty cycle' );

				if ( scene.userData.recreateRay ) {

					// Parameters which need to recreate the ray after modification

					var raySlowFolder = gui.addFolder( "Ray parameters (slow)" );

					raySlowFolder.add( scene.rayParams, 'ramification', 0, 15 ).step( 1 ).name( 'Ramification' ).onFinishChange( function () {

						scene.userData.recreateRay();

					} );

					raySlowFolder.add( scene.rayParams, 'maxSubrayRecursion', 0, 5 ).step( 1 ).name( 'Recursion' ).onFinishChange( function () {

						scene.userData.recreateRay();

					} );

					raySlowFolder.add( scene.rayParams, 'recursionProbability', 0, 1 ).name( 'Rec. probability' ).onFinishChange( function () {

						scene.recreateRay();

					} );

					raySlowFolder.open();

				}

				rayFolder.open();

			}
			

			//

			function animate() {

				requestAnimationFrame( animate );

				render();


			}

			function render() {

				currentTime += scene.timeRate * clock.getDelta();

            if ( currentTime < 0 ) {

					currentTime = 0;

				}

			scene.render( currentTime );

			}

			function createOutline( scene, objectsArray, visibleColor ) {

				var outlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, scene.camera, objectsArray );
				outlinePass.edgeStrength = 2.5;
				outlinePass.edgeGlow = 0.7;
				outlinePass.edgeThickness = 2.8;
				outlinePass.visibleEdgeColor = visibleColor;
				outlinePass.hiddenEdgeColor.set( 0 );
				composer.addPass( outlinePass );

				scene.outlineEnabled = true;

				return outlinePass;

			}

			//

			function createConesScene() {

				var scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );

				scene.canGoBackwardsInTime = true;

				//scene.camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 200, 100000 );
	            //scene.camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 0.01, 500 );
	            scene.camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 0.01, 500);
	            //scene.camera.position.set( 0, 0, 1);
				scene.camera.position.z = 1;
				// Lights

				scene.lightningColor = new THREE.Color( 0xffffff );
				scene.outlineColor = new THREE.Color( 0xff0000 );

				var posLight = new THREE.PointLight( 0x00ffff, 1, 5000, 2 );
				scene.add( posLight );


				// Cones

				var conesDistance = 2;
				var coneHeight = 1;
				var coneHeightHalf = coneHeight * 0.5;

				posLight.position.set( 0, 0.5, 0 );
				posLight.color = scene.outlineColor;



				//var coneMesh1 = new THREE.Mesh( new THREE.ConeBufferGeometry( coneHeight, coneHeight, 30, 1, false ), new THREE.MeshPhongMaterial( { color: 0xFFFF00, emissive: 0x1F1F00 } ) );
				var coneMesh1 = new THREE.Mesh( new THREE.ConeBufferGeometry( 0.1, 0.1, 30, 1, false ), new THREE.MeshPhongMaterial( { color: 0xFFFF00, opacity: 0, transparent: true } ) );				
				coneMesh1.rotation.z = -Math.PI/2;
				coneMesh1.position.set( -0.3, 0.1, 0.2 );
				scene.add( coneMesh1 );

				var coneMesh2 = new THREE.Mesh( coneMesh1.geometry.clone(), new THREE.MeshPhongMaterial( { color: 0xFFFF00, opacity: 0, transparent: true  } ) );
				coneMesh2.rotation.z = Math.PI/2;
				coneMesh2.position.set( 0.25, 0.1, 0.2 );
				scene.add( coneMesh2 );

				// Lightning strike

				scene.lightningMaterial = new THREE.MeshBasicMaterial( { color: scene.lightningColor } );

				scene.rayParams = {

					sourceOffset: new THREE.Vector3(),
					destOffset: new THREE.Vector3(),
					radius0: 0.01,
					radius1: 0.01,
					minRadius: 0.18,
				    radius0Factor: 0.18,
				    radius1Factor: 0.2,					
					maxIterations: 7,
					isEternal: true,

					timeScale: 0.7,

					propagationTimeFactor: 0.05,
					vanishingTimeFactor: 0.95,
					subrayPeriod: 3.5,
					subrayDutyCycle: 0.6,
					maxSubrayRecursion: 3,
					ramification: 7,
					recursionProbability: 0.6,

					roughness: 1,
					straightness: 0.55

				};

				var lightningStrike;
				var lightningStrikeMesh;
				var outlineMeshArray = [];

				scene.recreateRay = function () {

					if ( lightningStrikeMesh ) {

						scene.remove( lightningStrikeMesh );

					}

					lightningStrike = new LightningStrike( scene.rayParams );
					lightningStrikeMesh = new THREE.Mesh( lightningStrike, scene.lightningMaterial );

					outlineMeshArray.length = 0;
					outlineMeshArray.push( lightningStrikeMesh );

					scene.add( lightningStrikeMesh );

				};

				scene.recreateRay();

				// Compose rendering

				composer.passes = [];
				composer.addPass( new RenderPass( scene, scene.camera ) );
				createOutline( scene, outlineMeshArray, scene.outlineColor );

				// Controls

				var controls = new OrbitControls( scene.camera, renderer.domElement );
				//controls.target.y = ( conesDistance + coneHeight ) * 0.5;
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;

				scene.render = function ( time ) {

					// Move cones and Update ray position
					//coneMesh1.position.set( Math.sin( 0.5 * time ) * conesDistance * 0.6, conesDistance + coneHeight, Math.cos( 0.5 * time ) * conesDistance * 0.6 );
					//coneMesh2.position.set( Math.sin( 0.9 * time ) * conesDistance, coneHeightHalf, 0 );
					lightningStrike.rayParameters.sourceOffset.copy( coneMesh1.position );
					//lightningStrike.rayParameters.sourceOffset.y -= coneHeightHalf;
					lightningStrike.rayParameters.destOffset.copy( coneMesh2.position );
					//lightningStrike.rayParameters.destOffset.y += coneHeightHalf;

					lightningStrike.update( time );

					controls.update();

					// Update point light position to the middle of the ray
					posLight.position.lerpVectors( lightningStrike.rayParameters.sourceOffset, lightningStrike.rayParameters.destOffset, 0.5 );

					if ( scene.outlineEnabled ) {

						composer.render();

					}	else {

						renderer.render( scene, scene.camera );

					}

				};

				return scene;

			}

		</script>

	</body>
</html>
